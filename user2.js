// ========================================================================================================================
// Ранее мы научились получать доступ к элементам, их родителям, детям и соседям, а так-же менять их текстовое и html-содержимое
//это самая база, но у textContent и innerHTML есть фатальный минус, он стирает безвозвратно то что было перед его вызовом
// Теперь мы рассмотрим больше разных способов взаимодействия с нодами
// ========================================================================================================================
const element = document.querySelector('.container');
//------------------------------------------------
// Самое простое - удаление элемента (setTimeout просто для наглядности, он не обязателен)
// setTimeout(()=> element.remove(), 3000)
//------------------------------------------------
// Наполнение контентом: 
// append - вставляет контент в самый конец тега
const testAppendElement = document.querySelector('.append')
testAppendElement.append('Text-append-1 ')
testAppendElement.append('Text-append-2 ')
testAppendElement.append('Text-append-3 ')
testAppendElement.append('Text-append-4 ')
// prepend - вставляет в самое начало
const testPrependElement = document.querySelector('.prepend')
testAppendElement.prepend('Text-prepend-1 ')
testAppendElement.prepend('Text-prepend-2 ')
testAppendElement.prepend('Text-prepend-3 ')
testAppendElement.prepend('Text-prepend-4 ')
// ------------------------------------------------
const testBeforeAfterElement = document.querySelector('.before-after')
// before - вставляет перед тегом что-то
// after - вставляет после тега что-то
testBeforeAfterElement.before('Before tag')
testBeforeAfterElement.before('Before tag1')
testBeforeAfterElement.after('After tag')
testBeforeAfterElement.after('After tag1')
// ------------------------------------------------
// ------------------------------------------------
// Создание элемента createElement
// отдельно потому что для создания нам снова надо обратиться к document.
// Т.е. это операция того же уровня ну или из того же объекта что и поиск элементов
const newElement = document.createElement('button') 
//Вот мы создали элемент, на странице пока его нет, мы его туда не поместили. Пока нам надо его "доделать":
newElement.textContent = 'BTN' 
element.before(newElement) // Вставляем перед контейнером на страницу, в этот момент кнопка появляется в html-странице
element.after(newElement) // Вставляем после контейнера на страницу, в этот момент кнопка переместится
// Короче говоря, когда мы применяем before или after к одной и той же кнопке то мы не создаем 
// новую кнопку, а просто перемещаем созданную. 
// ------------------------------------------------
// ------------------------------------------------
// Для простого создания кнопки предыдущий способ показал себя довольно неплохо, однако если бы мы захотели создать список - 
// нам нужно было бы сначала созать ul, а потом через innerHTML пихать туда элементы списка. Это не очень удобно. 
// Вместо этого можно воспользоваться insertAdjacentHTML - это позволит впихнуть целый кусок html-кода 
element.insertAdjacentHTML('beforebegin', '<p style="color: red">Beforebegin text</p>')
element.insertAdjacentHTML('afterbegin', '<p style="color: green">Afterbegin text</p>')
element.insertAdjacentHTML('beforeend', '<p style="color: green">Beforeend text</p>')
element.insertAdjacentHTML('afterend', '<p style="color: red">Afterend text</p>')
//Красным цветом я обозначил то что не вошло внутрь тега. Т.е. этот html создался как-бы "снаружи" указанного тега
//Зеленым цветом я обозначил то что вошло внутрь тега. Т.е. этот html создался как-бы "внутри" указанного тега 
//для наглядности контейнеру я задал border того же цвета, чтобы было ясно где границы контейнера
// ========================================================================================================================
// Интересный факт:
// querySelector мы можем вызвать не только у document - но и у отдельных html-элементов, тогда, если я правильно понимаю, 
// поиск будет среди дочерних элементов
// ========================================================================================================================
// Итог:
// В отличии от предыдущего урока мы рассмотрели методы вставки, которые не затирают предыдущее содержимое, а добавляют к нему
// новое. Таким образом если мы в список хотим програмно добавить еще один пункт - теперь мы можем это сделать.
// ========================================================================================================================